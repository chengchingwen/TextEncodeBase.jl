<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · TextEncodeBase.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://chengchingwen.github.io/TextEncodeBase.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>TextEncodeBase.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/master/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="TextEncodeBase"><a class="docs-heading-anchor" href="#TextEncodeBase">TextEncodeBase</a><a id="TextEncodeBase-1"></a><a class="docs-heading-anchor-permalink" href="#TextEncodeBase" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/chengchingwen/TextEncodeBase.jl">TextEncodeBase</a>.</p><ul><li><a href="#TextEncodeBase.AbstractTokenization"><code>TextEncodeBase.AbstractTokenization</code></a></li><li><a href="#TextEncodeBase.AbstractTokenizer"><code>TextEncodeBase.AbstractTokenizer</code></a></li><li><a href="#TextEncodeBase.FlatTokenizer"><code>TextEncodeBase.FlatTokenizer</code></a></li><li><a href="#TextEncodeBase.NestedTokenizer"><code>TextEncodeBase.NestedTokenizer</code></a></li><li><a href="#TextEncodeBase.Splittability"><code>TextEncodeBase.Splittability</code></a></li><li><a href="#TextEncodeBase.TokenStages"><code>TextEncodeBase.TokenStages</code></a></li><li><a href="#TextEncodeBase.Vocab"><code>TextEncodeBase.Vocab</code></a></li><li><a href="#TextEncodeBase.lookup"><code>TextEncodeBase.lookup</code></a></li><li><a href="#TextEncodeBase.lookup-Tuple{Vocab, OneHotArray}"><code>TextEncodeBase.lookup</code></a></li><li><a href="#TextEncodeBase.lookup-Tuple{Type{OneHot}, Vocab, Any}"><code>TextEncodeBase.lookup</code></a></li><li><a href="#TextEncodeBase.lookup-Tuple{Vocab, AbstractArray}"><code>TextEncodeBase.lookup</code></a></li><li><a href="#TextEncodeBase.nested2batch-Tuple{Any}"><code>TextEncodeBase.nested2batch</code></a></li><li><a href="#TextEncodeBase.preprocess-Tuple{AbstractTokenizer, TextEncodeBase.TokenStages}"><code>TextEncodeBase.preprocess</code></a></li><li><a href="#TextEncodeBase.splittability"><code>TextEncodeBase.splittability</code></a></li><li><a href="#TextEncodeBase.splittable-Tuple"><code>TextEncodeBase.splittable</code></a></li><li><a href="#TextEncodeBase.splitting"><code>TextEncodeBase.splitting</code></a></li><li><a href="#TextEncodeBase.tokenization-Tuple{AbstractTokenizer}"><code>TextEncodeBase.tokenization</code></a></li><li><a href="#TextEncodeBase.tokenize_procedure-Tuple{Any, Any, Any}"><code>TextEncodeBase.tokenize_procedure</code></a></li><li><a href="#TextEncodeBase.trunc_and_pad-Tuple{Any, Integer, Any}"><code>TextEncodeBase.trunc_and_pad</code></a></li><li><a href="#TextEncodeBase.with_head_tail-Tuple{Any, Any, Any}"><code>TextEncodeBase.with_head_tail</code></a></li><li><a href="#TextEncodeBase.wrap"><code>TextEncodeBase.wrap</code></a></li><li><a href="#TextEncodeBase.wrap-Tuple{AbstractTokenization, TextEncodeBase.TokenStages}"><code>TextEncodeBase.wrap</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.AbstractTokenization" href="#TextEncodeBase.AbstractTokenization"><code>TextEncodeBase.AbstractTokenization</code></a> — <span class="docstring-category">Type</span></header><section><div><p>abstract type for tokenization.</p><p>The tokenization procedure is separate into multiple  <code>TokenStages</code> and recursive calls of <code>splitting</code>, <code>wrap</code>,  and <code>tokenize</code>. <code>splitting</code> break string into substrings,  <code>wrap</code> mark the substrings with new <code>TokenStages</code>, and  <code>tokenize</code> is responsible for the tokenization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/fad52f80b851338cab52459e7182b465ee3ae8ad/src/base.jl#L16-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.AbstractTokenizer" href="#TextEncodeBase.AbstractTokenizer"><code>TextEncodeBase.AbstractTokenizer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>abstract type for tokenizers.</p><p>Each tokenizer is link with a tokenization (by  defining <code>tokenization(::Tokenizer) = Tokenization()</code>).  The overall framework dispatch on both tokenizer and  tokenization, but most of the time we only add methods  for tokenization. This allow further composability and  can interfere the tokenization process with given  tokenizer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/fad52f80b851338cab52459e7182b465ee3ae8ad/src/base.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.FlatTokenizer" href="#TextEncodeBase.FlatTokenizer"><code>TextEncodeBase.FlatTokenizer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>tokenizer that return flat array instead of nested array of tokens</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/fad52f80b851338cab52459e7182b465ee3ae8ad/src/tkrs.jl#L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.NestedTokenizer" href="#TextEncodeBase.NestedTokenizer"><code>TextEncodeBase.NestedTokenizer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>tokenizer that return nested array instead of flat array of tokens</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/fad52f80b851338cab52459e7182b465ee3ae8ad/src/tkrs.jl#L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.Splittability" href="#TextEncodeBase.Splittability"><code>TextEncodeBase.Splittability</code></a> — <span class="docstring-category">Type</span></header><section><div><p>splittability trait</p><p>The splittability trait decide whether the given combination (tokenizer x tokenization x stage) is  splittable or not (<code>Splittable</code> or <code>UnSplittable</code>). For example, <code>DefaultTokenization</code> and <code>SentenceStage</code>  is splittable (i.e. <code>splittability(::DefaultTokenization, ::SentenceStage) = Splittable()</code>). The splittability  change the behavior of <code>tokenize</code>: if it&#39;s splittable, <code>tokenize</code> will try to call <code>splitting</code> on the input,  <code>wrap</code> each splitting result and recurse. Otherwise, it will directly call <code>wrap</code> and then recurse into <code>tokenize</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/fad52f80b851338cab52459e7182b465ee3ae8ad/src/base.jl#L107-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.TokenStages" href="#TextEncodeBase.TokenStages"><code>TextEncodeBase.TokenStages</code></a> — <span class="docstring-category">Type</span></header><section><div><p>abstract type for type that wrap input into specific stage for control tokenization.</p><p>There are six builtin stages in TextEncodeBase (all abstract XStage &lt;: TokenStages):</p><pre><code class="nohighlight hljs">1. Document &lt;: DocumentStage: the input string is a full document,
 and thus need to be splitted into multiple sentence.
2. Sentence &lt;: SentenceStage: the input string is a full string,
 and thus need to be splitted into multiple part (SubSentence/Word/Token).
3. SubSentence &lt;: SubSentenceStage: special wrapper for case where the tokenizer
 does not directly break sentence all into words/tokens and these pieces contain
 multiple words/tokens, but you need the information that they are not full sentence.
4. Word &lt;: WordStage: the input string is a single word.
5. SubWord &lt;: SubWordStage: similar to SubSentence, but for word.
6. Token &lt;: TokenStage: the final piece of the tokenization process.
 Generally, it&#39;s used to specify the end of this piece and should
 never be splitted.</code></pre><p>Each wrapper have two field: <code>x</code> for the input, <code>meta</code> for extra information (<code>nothing</code> if not provided).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/fad52f80b851338cab52459e7182b465ee3ae8ad/src/base.jl#L27-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.Vocab" href="#TextEncodeBase.Vocab"><code>TextEncodeBase.Vocab</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Vocab(data::Vector{&lt;:AbstractString}, unk::AbstractString=&quot;[UNK]&quot;)</code></pre><p>Constructor for <code>Vocab</code>. <code>data</code> is the list of vocabulary word, can be nonunique.  The actual list will be the unique version of <code>data</code> (i.e. <code>vocab.list = unique(data)</code>).  <code>unk</code> is the indicator word for all unknown words. <code>unk</code> can be either in or not in <code>data</code>,  depends on the use case.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/fad52f80b851338cab52459e7182b465ee3ae8ad/src/vocab.jl#L11-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.lookup" href="#TextEncodeBase.lookup"><code>TextEncodeBase.lookup</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lookup(v::Vocab, x)</code></pre><p>Lookup <code>x</code> in <code>v</code>. <code>lookup</code> words depends on the type of <code>x</code>. If <code>x</code> is an integer,  return the <code>x</code>-th word on the vocabulary list (i.e. <code>v.list[x]</code>) and return the unknown word  if <code>x</code> is out-of-bound (<code>v.unk</code>). If <code>x</code> is a string, return the indice of <code>x</code> in the vocabulary  list (i.e <code>findfirst(==(x), v.list</code>) and return the unknown indice if <code>x</code> not found in the list.  If the unknown word <code>v.unk</code> is in the list, the unknown indice is its indice, otherwise 0.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; vocab = Vocab([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;])
Vocab{String, StaticArrays.SizedVector{3, String, Vector{String}}}(size = 3, unk = [UNK], unki = 0)

julia&gt; vocab_unk = Vocab([&quot;a&quot;, &quot;b&quot;, &quot;xxx&quot;], &quot;xxx&quot;)
Vocab{String, StaticArrays.SizedVector{3, String, Vector{String}}}(size = 3, unk = xxx, unki = 3)

julia&gt; lookup(vocab, &quot;b&quot;)
2

julia&gt; lookup(vocab, &quot;d&quot;)
0

julia&gt; lookup(vocab_unk, &quot;d&quot;)
3

julia&gt; lookup(vocab, 1)
&quot;a&quot;

julia&gt; lookup(vocab, 10000)
&quot;[UNK]&quot;

julia&gt; lookup(vocab_unk, 10000)
&quot;xxx&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/fad52f80b851338cab52459e7182b465ee3ae8ad/src/vocab.jl#L70-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.lookup-Tuple{Type{OneHot}, Vocab, Any}" href="#TextEncodeBase.lookup-Tuple{Type{OneHot}, Vocab, Any}"><code>TextEncodeBase.lookup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lookup(OneHot, v::Vocab, i)</code></pre><p>lookup <code>i</code> and convert into one-hot representation.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; lookup(OneHot, vocab, &quot;a&quot;)
3-element OneHot{3}:
 1
 0
 0

julia&gt; lookup(OneHot, vocab, [&quot;a&quot; &quot;b&quot;; &quot;c&quot; &quot;d&quot;])
3x2x2 OneHotArray{3, 3, Matrix{OneHot{0x00000003}}}:
[:, :, 1] =
 1  0
 0  0
 0  1

[:, :, 2] =
 0  0
 1  0
 0  0

julia&gt; lookup(OneHot, vocab, 3)
ERROR: DomainError with c:
cannot convert `lookup(::Vocab, 3)` = &quot;c&quot; into one-hot representation.
Stacktrace:
[...]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/fad52f80b851338cab52459e7182b465ee3ae8ad/src/vocab.jl#L137-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.lookup-Tuple{Vocab, AbstractArray}" href="#TextEncodeBase.lookup-Tuple{Vocab, AbstractArray}"><code>TextEncodeBase.lookup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lookup(v::Vocab, is::AbstractArray)</code></pre><p>recursively lookup value from <code>is</code></p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; lookup(vocab, [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;A&quot;, &quot;[UNK]&quot;])
5-element Vector{Int64}:
 2
 3
 1
 0
 0

julia&gt; lookup(vocab, [1, &quot;a&quot;, 0, &quot;A&quot;, &quot;[UNK]&quot;])
5-element Vector{Any}:
  &quot;a&quot;
 1
  &quot;[UNK]&quot;
 0
 0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/fad52f80b851338cab52459e7182b465ee3ae8ad/src/vocab.jl#L109-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.lookup-Tuple{Vocab, OneHotArray}" href="#TextEncodeBase.lookup-Tuple{Vocab, OneHotArray}"><code>TextEncodeBase.lookup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lookup(v::Vocab, i::OneHotArray)</code></pre><p>convert the one-hot representation back into words.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; lookup(OneHot, vocab, [&quot;a&quot; &quot;b&quot;; &quot;c&quot; &quot;d&quot;])
3x2x2 OneHotArray{3, 3, Matrix{OneHot{0x00000003}}}:
[:, :, 1] =
 1  0
 0  0
 0  1

[:, :, 2] =
 0  0
 1  0
 0  0

julia&gt; lookup(vocab, ans)
2×2 Matrix{String}:
 &quot;a&quot;  &quot;b&quot;
 &quot;c&quot;  &quot;[UNK]&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/fad52f80b851338cab52459e7182b465ee3ae8ad/src/vocab.jl#L173-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.nested2batch-Tuple{Any}" href="#TextEncodeBase.nested2batch-Tuple{Any}"><code>TextEncodeBase.nested2batch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nested2batch(x)</code></pre><p>convert nested array into single array</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; TextEncodeBase.nested2batch([[[1 2],[3 4]]])
1×2×2×1 Array{Int64, 4}:
[:, :, 1, 1] =
 1  2

[:, :, 2, 1] =
 3  4
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/fad52f80b851338cab52459e7182b465ee3ae8ad/src/utils.jl#L187-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.preprocess-Tuple{AbstractTokenizer, TextEncodeBase.TokenStages}" href="#TextEncodeBase.preprocess-Tuple{AbstractTokenizer, TextEncodeBase.TokenStages}"><code>TextEncodeBase.preprocess</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">preprocess(tkr::AbstractTokenizer, x)</code></pre><p>Preprocess the input <code>x</code>. This is only called during <code>tkr(x)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/fad52f80b851338cab52459e7182b465ee3ae8ad/src/base.jl#L270-L274">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.splittability" href="#TextEncodeBase.splittability"><code>TextEncodeBase.splittability</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">splittability(args...)</code></pre><p>Return the splittability (<code>Splittable</code>/<code>UnSplittable</code>) of given argument combination.  Overload to make a <code>TokenStages</code> splittable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/fad52f80b851338cab52459e7182b465ee3ae8ad/src/base.jl#L120-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.splittable-Tuple" href="#TextEncodeBase.splittable-Tuple"><code>TextEncodeBase.splittable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">splittable(args...)</code></pre><p>Return <code>true</code> if the splittability of given argument combination is <code>Splittable()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/fad52f80b851338cab52459e7182b465ee3ae8ad/src/base.jl#L128-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.splitting" href="#TextEncodeBase.splitting"><code>TextEncodeBase.splitting</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">splitting(t::AbstractTokenization, x::TokenStages)</code></pre><p>Split <code>x</code> given its tokenization stage. For example,  the default behavior of a document stage is splitting into  sentences (with <code>WordTokenizers.split_sentences</code>).</p><p>Overload this method for custom tokenization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/fad52f80b851338cab52459e7182b465ee3ae8ad/src/base.jl#L193-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.tokenization-Tuple{AbstractTokenizer}" href="#TextEncodeBase.tokenization-Tuple{AbstractTokenizer}"><code>TextEncodeBase.tokenization</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tokenization(::AbstractTokenizer) :: AbstractTokenization</code></pre><p>Return the tokenization type of given tokenizer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/fad52f80b851338cab52459e7182b465ee3ae8ad/src/base.jl#L263-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.tokenize_procedure-Tuple{Any, Any, Any}" href="#TextEncodeBase.tokenize_procedure-Tuple{Any, Any, Any}"><code>TextEncodeBase.tokenize_procedure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tokenization_procedure(tokenizer, tokenizaton, stage)</code></pre><p>The procedure of tokenization (<code>splitting</code> + <code>wrap</code> + <code>tokenize</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/fad52f80b851338cab52459e7182b465ee3ae8ad/src/base.jl#L168-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.trunc_and_pad-Tuple{Any, Integer, Any}" href="#TextEncodeBase.trunc_and_pad-Tuple{Any, Integer, Any}"><code>TextEncodeBase.trunc_and_pad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">trunc_and_pad(x, n, pad)</code></pre><p>truncate <code>x</code> to length <code>n</code>, otherwise add <code>pad</code> at the end of x until length equal <code>n</code>.  <code>x</code> can be either nested or single array (but the element type should not be subtype of abstract array).  if <code>n</code> is <code>nothing</code>, the largest length of the nested array will be used.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; TextEncodeBase.trunc_and_pad(1:5, 7, -1)
7-element Vector{Int64}:
  1
  2
  3
  4
  5
 -1
 -1

julia&gt; TextEncodeBase.trunc_and_pad([1:5, 2:7], 7, -1)
2-element Vector{Vector{Int64}}:
 [1, 2, 3, 4, 5, -1, -1]
 [2, 3, 4, 5, 6, 7, -1]

julia&gt; TextEncodeBase.trunc_and_pad([1:5, [2:7, [1:2]]], nothing, -1)
2-element Vector{Vector}:
 [1, 2, 3, 4, 5, -1]
 Vector[[2, 3, 4, 5, 6, 7], [[1, 2, -1, -1, -1, -1]]]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/fad52f80b851338cab52459e7182b465ee3ae8ad/src/utils.jl#L130-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.with_head_tail-Tuple{Any, Any, Any}" href="#TextEncodeBase.with_head_tail-Tuple{Any, Any, Any}"><code>TextEncodeBase.with_head_tail</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">with_head_tail(x, head, tail)</code></pre><p>Return <code>[head; x; tail]</code>. Ignored if <code>head</code> or <code>tail</code> is <code>nothing</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; TextEncodeBase.with_head_tail(1:5, -1, -2)
7-element Vector{Int64}:
 -1
  1
  2
  3
  4
  5
 -2

julia&gt; TextEncodeBase.with_head_tail([1:5, 2:3], -1, -2)
2-element Vector{Vector{Int64}}:
 [-1, 1, 2, 3, 4, 5, -2]
 [-1, 2, 3, -2]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/fad52f80b851338cab52459e7182b465ee3ae8ad/src/utils.jl#L90-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.wrap" href="#TextEncodeBase.wrap"><code>TextEncodeBase.wrap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">wrap(t::AbstractTokenization, s::TokenStages, x)</code></pre><p>Mark the tokenization stage of <code>x</code>, which is part of the splitting result of <code>s</code>.  For example, if we are doing simple whitespace tokenization and at the sentence stage,  then <code>x</code> is just single word of <code>s</code> and thus return <code>Word(x)</code> (or <code>Token(x)</code>).  Skip if <code>x</code> is already a <code>TokenStages</code>. (this method only apply to splittable stages)</p><p>Overload this method to control the tokenization process.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/fad52f80b851338cab52459e7182b465ee3ae8ad/src/base.jl#L204-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.wrap-Tuple{AbstractTokenization, TextEncodeBase.TokenStages}" href="#TextEncodeBase.wrap-Tuple{AbstractTokenization, TextEncodeBase.TokenStages}"><code>TextEncodeBase.wrap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wrap(t::AbstractTokenization, x::TokenStages)</code></pre><p>A handler for unsplittable stages (token/word/...).</p><p>Overload this method for custom transform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/fad52f80b851338cab52459e7182b465ee3ae8ad/src/base.jl#L216-L222">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Thursday 10 February 2022 12:50">Thursday 10 February 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
