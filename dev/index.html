<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>TextEncodeBase · TextEncodeBase.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://chengchingwen.github.io/TextEncodeBase.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>TextEncodeBase.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><span class="tocitem">Home</span><ul><li class="is-active"><a class="tocitem" href>TextEncodeBase</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Usages"><span>Usages</span></a></li><li><a class="tocitem" href="#Vocabulary"><span>Vocabulary</span></a></li><li><a class="tocitem" href="#Tokenizer"><span>Tokenizer</span></a></li><li><a class="tocitem" href="#TextEncoder"><span>TextEncoder</span></a></li><li class="toplevel"><a class="tocitem" href="#Outline"><span>Outline</span></a></li></ul></li><li><a class="tocitem" href="design/">Design</a></li><li><a class="tocitem" href="api/">Api reference</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Home</a></li><li class="is-active"><a href>TextEncodeBase</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>TextEncodeBase</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/master/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="TextEncodeBase"><a class="docs-heading-anchor" href="#TextEncodeBase">TextEncodeBase</a><a id="TextEncodeBase-1"></a><a class="docs-heading-anchor-permalink" href="#TextEncodeBase" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/chengchingwen/TextEncodeBase.jl">TextEncodeBase</a>.</p><p>An api for encoding text, built on top of <a href="https://github.com/JuliaText/WordTokenizers.jl">WordTokenizers.jl</a>.  Providing a framework to easily define custom methods to convert strings into indices.</p><h1 id="Usages"><a class="docs-heading-anchor" href="#Usages">Usages</a><a id="Usages-1"></a><a class="docs-heading-anchor-permalink" href="#Usages" title="Permalink"></a></h1><p>Here are some explanation and examples for using <code>TextEncodeBase.jl</code>, you can also find other information  from the <a href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/main/test/runtests.jl">test</a></p><h2 id="Vocabulary"><a class="docs-heading-anchor" href="#Vocabulary">Vocabulary</a><a id="Vocabulary-1"></a><a class="docs-heading-anchor-permalink" href="#Vocabulary" title="Permalink"></a></h2><p>The vocabulary part contains only two api, the <code>Vocab</code> struct and the <code>lookup</code> function.  The <code>lookup</code> function is bidirectional (convert string to indices and back).</p><pre><code class="language-julia hljs">julia&gt; vocab = Vocab([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;])
Vocab{String, StaticArrays.SizedVector{3, String, Vector{String}}}(size = 3, unk = [UNK], unki = 0)

julia&gt; vocab_unk = Vocab([&quot;a&quot;, &quot;b&quot;, &quot;xxx&quot;], &quot;xxx&quot;)
Vocab{String, StaticArrays.SizedVector{3, String, Vector{String}}}(size = 3, unk = xxx, unki = 3)

julia&gt; lookup(vocab, &quot;b&quot;)
2

julia&gt; lookup(vocab, &quot;d&quot;)
0

julia&gt; lookup(vocab_unk, &quot;d&quot;)
3

julia&gt; lookup(vocab, 1)
&quot;a&quot;

julia&gt; lookup(vocab, 10000)
&quot;[UNK]&quot;

julia&gt; lookup(vocab_unk, 10000)
&quot;xxx&quot;

julia&gt; lookup(vocab, [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;A&quot;, &quot;[UNK]&quot;])
5-element Vector{Int64}:
 2
 3
 1
 0
 0

julia&gt; lookup(OneHot, vocab, &quot;a&quot;)
3-element OneHot{3}:
 1
 0
 0

julia&gt; lookup(OneHot, vocab, 3)
ERROR: DomainError with c:
cannot convert `lookup(::Vocab, 3)` = &quot;c&quot; into one-hot representation.
Stacktrace:
[...]

julia&gt; oha = lookup(OneHot, vocab, [&quot;a&quot; &quot;b&quot;; &quot;c&quot; &quot;d&quot;])
3x2x2 OneHotArray{3, 3, Matrix{OneHot{0x00000003}}}:
[:, :, 1] =
 1  0
 0  0
 0  1

[:, :, 2] =
 0  0
 1  0
 0  0

julia&gt; lookup(vocab, oha)
2×2 Matrix{String}:
 &quot;a&quot;  &quot;b&quot;
 &quot;c&quot;  &quot;[UNK]&quot;
</code></pre><h2 id="Tokenizer"><a class="docs-heading-anchor" href="#Tokenizer">Tokenizer</a><a id="Tokenizer-1"></a><a class="docs-heading-anchor-permalink" href="#Tokenizer" title="Permalink"></a></h2><p>The tokenizer part is built ontop of <code>WordTokenizers.jl</code> and provide a high-level api  to control/augment the tokenization. There&#39;re some differences between <code>WordTokenizers.jl</code>.  <code>WordTokenizers.jl</code> provides a set of tokenizers and a low-level api (<code>TokenBuffer</code>) for define  custom tokenizers. It&#39;s mainly focus on how to split a setnece into tokens. We, on the other hand,  focus on how to combine different tokenizer or include other information during the tokenization.  For example, sometimes you might want to prevent urls from being splited or add some extra tags to it,  these can be done by defining a custom <code>AbstractTokenizer</code> and overload some methods. Besides, we  force the user to explicit wrap the input as one of the stages (<code>Document</code>/<code>Sentence</code>/<code>Word</code>/...),  so no confusion.</p><h3 id="Example-of-using-the-Tokenizer-api"><a class="docs-heading-anchor" href="#Example-of-using-the-Tokenizer-api">Example of using the Tokenizer api</a><a id="Example-of-using-the-Tokenizer-api-1"></a><a class="docs-heading-anchor-permalink" href="#Example-of-using-the-Tokenizer-api" title="Permalink"></a></h3><p>Here is an example that wrapped the word tokenizer and wordpiece from <code>Transformers.jl</code> into our Tokenizer api.</p><pre><code class="language-julia hljs">using Transformers
using Transformers.Pretrain
using Transformers.BidirectionalEncoder: WordPiece, bert_cased_tokenizer

using TextEncodeBase
using TextEncodeBase: NestedTokenizer, BaseTokenization, Sentence, Word, SubWord, getvalue, Splittable

struct BertCasedTokenization &lt;: BaseTokenization
    wordpiece::WordPiece
end

# split sentence with `bert_cased_tokenizer` (define with WordTokenizers.jl&#39;s `TokenBuffer`)
TextEncodeBase.splitting(::BertCasedTokenization, s::Sentence) = bert_cased_tokenizer(getvalue(s))

# word is splittable with WordPiece
TextEncodeBase.splittability(::BertCasedTokenization, w::Word) = Splittable()

# split word with `WordPiece`
TextEncodeBase.splitting(t::BertCasedTokenization, w::Word) = t.wordpiece(getvalue(w))

tokenizer = pretrain&quot;bert-cased_L-12_H-768_A-12:tokenizer&quot; # this is just `bert_cased_tokenizer`
wordpiece = pretrain&quot;bert-cased_L-12_H-768_A-12:wordpiece&quot;

tkr = NestedTokenizer(BertCasedTokenization(wordpiece))

text1 = &quot;Peter Piper picked a peck of pickled peppers&quot;
single_without_TEB = text1 |&gt; tokenizer |&gt; wordpiece
single_with_TEB = tkr(Sentence(text1))

# `NestedTokenizer` return vector of vector
@assert single_without_TEB == map(getvalue, single_with_TEB[])

julia&gt; single_without_TEB
11-element Vector{String}:
 &quot;Peter&quot;
 &quot;Piper&quot;
 &quot;picked&quot;
 &quot;a&quot;
 &quot;p&quot;
 &quot;##eck&quot;
 &quot;of&quot;
 &quot;pick&quot;
 &quot;##led&quot;
 &quot;pepper&quot;
 &quot;##s&quot;

julia&gt; single_with_TEB
1-element Vector{Vector{TextEncodeBase.TokenStage}}:
 [Token(&quot;Peter&quot;), Token(&quot;Piper&quot;), Token(&quot;picked&quot;), Token(&quot;a&quot;), Token(&quot;p&quot;), Token(&quot;##eck&quot;), Token(&quot;of&quot;), Token(&quot;pick&quot;), Token(&quot;##led&quot;), Token(&quot;pepper&quot;), Token(&quot;##s&quot;)]

julia&gt; single_without_TEB == map(getvalue, single_with_TEB[])
true


# define stage for batch of data
struct BatchSentence{A&lt;:AbstractVector, M} &lt;: TextEncodeBase.DocumentStage
    x::A
    meta::M
end

BatchSentence(x) = BatchSentence(x, nothing)
TextEncodeBase.setmeta(x::BatchSentence, meta) = BatchSentence(x.x, meta)
TextEncodeBase.setvalue(x::BatchSentence, y) = BatchSentence(y, x.meta)

# splittability and split behavior for `BatchSentence`
TextEncodeBase.splittability(::BertCasedTokenization, ::BatchSentence) = Splittable()
TextEncodeBase.splitting(::BertCasedTokenization, s::BatchSentence) = s.x

text2 = &quot;Fuzzy Wuzzy was a bear&quot;
texts = [text1, text2]

batch_without_TEB = map(wordpiece∘tokenizer, texts)
batch_with_TEB = tkr(BatchSentence(texts))

@assert batch_without_TEB == TextEncodeBase.nestedcall(getvalue, batch_with_TEB)

julia&gt; batch_without_TEB
2-element Vector{Vector{String}}:
 [&quot;Peter&quot;, &quot;Piper&quot;, &quot;picked&quot;, &quot;a&quot;, &quot;p&quot;, &quot;##eck&quot;, &quot;of&quot;, &quot;pick&quot;, &quot;##led&quot;, &quot;pepper&quot;, &quot;##s&quot;]
 [&quot;Fu&quot;, &quot;##zzy&quot;, &quot;Wu&quot;, &quot;##zzy&quot;, &quot;was&quot;, &quot;a&quot;, &quot;bear&quot;]

julia&gt; batch_with_TEB
2-element Vector{Vector{TextEncodeBase.TokenStage}}:
 [Token(&quot;Peter&quot;), Token(&quot;Piper&quot;), Token(&quot;picked&quot;), Token(&quot;a&quot;), Token(&quot;p&quot;), Token(&quot;##eck&quot;), Token(&quot;of&quot;), Token(&quot;pick&quot;), Token(&quot;##led&quot;), Token(&quot;pepper&quot;), Token(&quot;##s&quot;)]
 [Token(&quot;Fu&quot;), Token(&quot;##zzy&quot;), Token(&quot;Wu&quot;), Token(&quot;##zzy&quot;), Token(&quot;was&quot;), Token(&quot;a&quot;), Token(&quot;bear&quot;)]

julia&gt; batch_without_TEB == TextEncodeBase.nestedcall(getvalue, batch_with_TEB)
true
</code></pre><p>Since the wordpiece break word into subword, we might want to know which word each subword belongs to:</p><pre><code class="language-julia hljs">julia&gt; itkr = NestedTokenizer(TextEncodeBase.IndexedTokenization(BertCasedTokenization(wordpiece)));

julia&gt; ibatch_with_TEB = itkr(BatchSentence(texts));

# subword from same word having the same `word_id`
julia&gt; ibatch_with_TEB[1]
11-element Vector{TextEncodeBase.TokenStage}:
 Token(&quot;Peter&quot;, (sentence_id = 1, word_id = 1, token_id = 1))
 Token(&quot;Piper&quot;, (sentence_id = 1, word_id = 2, token_id = 2))
 Token(&quot;picked&quot;, (sentence_id = 1, word_id = 3, token_id = 3))
 Token(&quot;a&quot;, (sentence_id = 1, word_id = 4, token_id = 4))
 Token(&quot;p&quot;, (sentence_id = 1, word_id = 5, token_id = 5))
 Token(&quot;##eck&quot;, (sentence_id = 1, word_id = 5, token_id = 6))
 Token(&quot;of&quot;, (sentence_id = 1, word_id = 6, token_id = 7))
 Token(&quot;pick&quot;, (sentence_id = 1, word_id = 7, token_id = 8))
 Token(&quot;##led&quot;, (sentence_id = 1, word_id = 7, token_id = 9))
 Token(&quot;pepper&quot;, (sentence_id = 1, word_id = 8, token_id = 10))
 Token(&quot;##s&quot;, (sentence_id = 1, word_id = 8, token_id = 11))

julia&gt; ibatch_with_TEB[2]
7-element Vector{TextEncodeBase.TokenStage}:
 Token(&quot;Fu&quot;, (sentence_id = 2, word_id = 1, token_id = 1))
 Token(&quot;##zzy&quot;, (sentence_id = 2, word_id = 1, token_id = 2))
 Token(&quot;Wu&quot;, (sentence_id = 2, word_id = 2, token_id = 3))
 Token(&quot;##zzy&quot;, (sentence_id = 2, word_id = 2, token_id = 4))
 Token(&quot;was&quot;, (sentence_id = 2, word_id = 3, token_id = 5))
 Token(&quot;a&quot;, (sentence_id = 2, word_id = 4, token_id = 6))
 Token(&quot;bear&quot;, (sentence_id = 2, word_id = 5, token_id = 7))
</code></pre><h2 id="TextEncoder"><a class="docs-heading-anchor" href="#TextEncoder">TextEncoder</a><a id="TextEncoder-1"></a><a class="docs-heading-anchor-permalink" href="#TextEncoder" title="Permalink"></a></h2><p>The text encoder is just a combination of vocabulary and tokenizer. We also  provide some helper function like (<code>with_head_tail</code>/<code>nested2batch</code>/...) for  transform the tokenizer result into <code>lookup</code>-able format.</p><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><pre><code class="language-julia hljs">using TextEncodeBase: nestedcall, with_head_tail, trunc_and_pad, nested2batch

# construct `Vocab` with `WordPiece`
vocab = Vocab(wordpiece.vocab, wordpiece.vocab[wordpiece.unk_idx])

# define encoder with `TextEncoder`
encoder = TextEncoder(
    itkr, vocab,
    nested2batch ∘ trunc_and_pad(nothing, vocab.unk) ∘ with_head_tail(&quot;[CLS]&quot;, &quot;[SEP]&quot;) ∘ nestedcall(getvalue)
)

julia&gt; encode(enc, BatchSentence(texts))
28996x13x2 OneHotArray{28996, 3, Matrix{OneHot{0x00007144}}}:
[...]

julia&gt; decode(enc, ans)
13×2 Matrix{String}:
 &quot;[CLS]&quot;   &quot;[CLS]&quot;
 &quot;Peter&quot;   &quot;Fu&quot;
 &quot;Piper&quot;   &quot;##zzy&quot;
 &quot;picked&quot;  &quot;Wu&quot;
 &quot;a&quot;       &quot;##zzy&quot;
 &quot;p&quot;       &quot;was&quot;
 &quot;##eck&quot;   &quot;a&quot;
 &quot;of&quot;      &quot;bear&quot;
 &quot;pick&quot;    &quot;[SEP]&quot;
 &quot;##led&quot;   &quot;[UNK]&quot;
 &quot;pepper&quot;  &quot;[UNK]&quot;
 &quot;##s&quot;     &quot;[UNK]&quot;
 &quot;[SEP]&quot;   &quot;[UNK]&quot;
</code></pre><h1 id="Outline"><a class="docs-heading-anchor" href="#Outline">Outline</a><a id="Outline-1"></a><a class="docs-heading-anchor-permalink" href="#Outline" title="Permalink"></a></h1><ul><li><a href="design/#Design">Design</a></li><li class="no-marker"><ul><li><a href="design/#Tokenizer">Tokenizer</a></li><li><a href="design/#Vocabulary">Vocabulary</a></li></ul></li><li><a href="api/#Api-reference">Api reference</a></li></ul></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="design/">Design »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Thursday 10 February 2022 16:18">Thursday 10 February 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
