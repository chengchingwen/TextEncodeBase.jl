<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Api reference · TextEncodeBase.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://chengchingwen.github.io/TextEncodeBase.jl/api/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">TextEncodeBase.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><span class="tocitem">Home</span><ul><li><a class="tocitem" href="../">TextEncodeBase</a></li><li><a class="tocitem" href="../design/">Design</a></li><li class="is-active"><a class="tocitem" href>Api reference</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Home</a></li><li class="is-active"><a href>Api reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Api reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/master/docs/src/api.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Api-reference"><a class="docs-heading-anchor" href="#Api-reference">Api reference</a><a id="Api-reference-1"></a><a class="docs-heading-anchor-permalink" href="#Api-reference" title="Permalink"></a></h1><ul><li><a href="#TextEncodeBase.AbstractTokenization"><code>TextEncodeBase.AbstractTokenization</code></a></li><li><a href="#TextEncodeBase.AbstractTokenizer"><code>TextEncodeBase.AbstractTokenizer</code></a></li><li><a href="#TextEncodeBase.ConstTerm"><code>TextEncodeBase.ConstTerm</code></a></li><li><a href="#TextEncodeBase.FlatTokenizer"><code>TextEncodeBase.FlatTokenizer</code></a></li><li><a href="#TextEncodeBase.IndexInputTerm"><code>TextEncodeBase.IndexInputTerm</code></a></li><li><a href="#TextEncodeBase.InputTerm"><code>TextEncodeBase.InputTerm</code></a></li><li><a href="#TextEncodeBase.NestedTokenizer"><code>TextEncodeBase.NestedTokenizer</code></a></li><li><a href="#TextEncodeBase.RepeatedTerm"><code>TextEncodeBase.RepeatedTerm</code></a></li><li><a href="#TextEncodeBase.SequenceTemplate"><code>TextEncodeBase.SequenceTemplate</code></a></li><li><a href="#TextEncodeBase.Splittability"><code>TextEncodeBase.Splittability</code></a></li><li><a href="#TextEncodeBase.TemplateTerm"><code>TextEncodeBase.TemplateTerm</code></a></li><li><a href="#TextEncodeBase.TextEncoder"><code>TextEncodeBase.TextEncoder</code></a></li><li><a href="#TextEncodeBase.TextEncoder-Tuple{Any, TextEncoder}"><code>TextEncodeBase.TextEncoder</code></a></li><li><a href="#TextEncodeBase.TokenStages"><code>TextEncodeBase.TokenStages</code></a></li><li><a href="#TextEncodeBase.Vocab"><code>TextEncodeBase.Vocab</code></a></li><li><a href="#TextEncodeBase.Vocab-Union{Tuple{T}, Tuple{AbstractVector, Any}} where T"><code>TextEncodeBase.Vocab</code></a></li><li><a href="#TextEncodeBase.decode-Tuple{AbstractTextEncoder, Any}"><code>TextEncodeBase.decode</code></a></li><li><a href="#TextEncodeBase.decode_indices-Tuple{AbstractTextEncoder, Any}"><code>TextEncodeBase.decode_indices</code></a></li><li><a href="#TextEncodeBase.encode-Tuple{AbstractTextEncoder, Any}"><code>TextEncodeBase.encode</code></a></li><li><a href="#TextEncodeBase.encode_indices-Tuple{AbstractTextEncoder, Any}"><code>TextEncodeBase.encode_indices</code></a></li><li><a href="#TextEncodeBase.lookup-Tuple{Type{OneHot}, Vocab, Any}"><code>TextEncodeBase.lookup</code></a></li><li><a href="#TextEncodeBase.lookup-Tuple{AbstractTextEncoder, Any}"><code>TextEncodeBase.lookup</code></a></li><li><a href="#TextEncodeBase.lookup-Tuple{Vocab, AbstractArray}"><code>TextEncodeBase.lookup</code></a></li><li><a href="#TextEncodeBase.lookup"><code>TextEncodeBase.lookup</code></a></li><li><a href="#TextEncodeBase.lookup-Tuple{Vocab, OneHotArray}"><code>TextEncodeBase.lookup</code></a></li><li><a href="#TextEncodeBase.lookup-Union{Tuple{T}, Tuple{Type{T}, Vocab{T, A} where A&lt;:AbstractVector{T}, Integer}} where T"><code>TextEncodeBase.lookup</code></a></li><li><a href="#TextEncodeBase.lookup-Tuple{Any, Vocab, Any}"><code>TextEncodeBase.lookup</code></a></li><li><a href="#TextEncodeBase.nested2batch-Tuple{Any}"><code>TextEncodeBase.nested2batch</code></a></li><li><a href="#TextEncodeBase.preprocess-Tuple{AbstractTokenizer, TextEncodeBase.TokenStages}"><code>TextEncodeBase.preprocess</code></a></li><li><a href="#TextEncodeBase.process-Tuple{AbstractTextEncoder}"><code>TextEncodeBase.process</code></a></li><li><a href="#TextEncodeBase.process-Tuple{AbstractTextEncoder, Any}"><code>TextEncodeBase.process</code></a></li><li><a href="#TextEncodeBase.splittability"><code>TextEncodeBase.splittability</code></a></li><li><a href="#TextEncodeBase.splittable-Tuple"><code>TextEncodeBase.splittable</code></a></li><li><a href="#TextEncodeBase.splitting"><code>TextEncodeBase.splitting</code></a></li><li><a href="#TextEncodeBase.tokenization-Tuple{AbstractTokenizer}"><code>TextEncodeBase.tokenization</code></a></li><li><a href="#TextEncodeBase.tokenize-Tuple{AbstractTextEncoder, Any}"><code>TextEncodeBase.tokenize</code></a></li><li><a href="#TextEncodeBase.tokenize_procedure-Tuple{Any, Any, Any}"><code>TextEncodeBase.tokenize_procedure</code></a></li><li><a href="#TextEncodeBase.trunc_and_pad"><code>TextEncodeBase.trunc_and_pad</code></a></li><li><a href="#TextEncodeBase.trunc_or_pad"><code>TextEncodeBase.trunc_or_pad</code></a></li><li><a href="#TextEncodeBase.with_head_tail-Tuple{AbstractArray, Any, Any}"><code>TextEncodeBase.with_head_tail</code></a></li><li><a href="#TextEncodeBase.wrap"><code>TextEncodeBase.wrap</code></a></li><li><a href="#TextEncodeBase.wrap-Tuple{AbstractTokenization, TextEncodeBase.TokenStages}"><code>TextEncodeBase.wrap</code></a></li><li><a href="#TextEncodeBase.@stage"><code>TextEncodeBase.@stage</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.AbstractTokenization" href="#TextEncodeBase.AbstractTokenization"><code>TextEncodeBase.AbstractTokenization</code></a> — <span class="docstring-category">Type</span></header><section><div><p>abstract type for tokenization.</p><p>The tokenization procedure is separate into multiple  <code>TokenStages</code> and recursive calls of <code>splitting</code>, <code>wrap</code>,  and <code>tokenize</code>. <code>splitting</code> break string into substrings,  <code>wrap</code> mark the substrings with new <code>TokenStages</code>, and  <code>tokenize</code> is responsible for the tokenization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/base.jl#L16-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.AbstractTokenizer" href="#TextEncodeBase.AbstractTokenizer"><code>TextEncodeBase.AbstractTokenizer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>abstract type for tokenizers.</p><p>Each tokenizer is link with a tokenization (by  defining <code>tokenization(::Tokenizer) = Tokenization()</code>).  The overall framework dispatch on both tokenizer and  tokenization, but most of the time we only add methods  for tokenization. This allow further composability and  can interfere the tokenization process with given  tokenizer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/base.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.ConstTerm" href="#TextEncodeBase.ConstTerm"><code>TextEncodeBase.ConstTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConstTerm(value::T, type_id = 1)</code></pre><p>A <code>TemplateTerm</code> that simply put <code>value</code> to the output sequence.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/utils.jl#L560-L564">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.FlatTokenizer" href="#TextEncodeBase.FlatTokenizer"><code>TextEncodeBase.FlatTokenizer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>tokenizer that return flat array instead of nested array of tokens</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/tkrs.jl#L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.IndexInputTerm" href="#TextEncodeBase.IndexInputTerm"><code>TextEncodeBase.IndexInputTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IndexInputTerm{T}(idx::Int, type_id = 1)</code></pre><p>A <code>TemplateTerm</code> that take the <code>idx</code>-th sequence of the input. If the <code>IndexInputTerm</code> is also the <code>idx</code>-th  input related term in a <a href="#TextEncodeBase.SequenceTemplate"><code>SequenceTemplate</code></a>, it behave the same as <a href="#TextEncodeBase.InputTerm"><code>InputTerm</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/utils.jl#L548-L553">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.InputTerm" href="#TextEncodeBase.InputTerm"><code>TextEncodeBase.InputTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InputTerm{T}(type_id = 1)</code></pre><p>A <code>TemplateTerm</code> that take out a sequence from the input.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/utils.jl#L538-L542">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.NestedTokenizer" href="#TextEncodeBase.NestedTokenizer"><code>TextEncodeBase.NestedTokenizer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>tokenizer that return nested array instead of flat array of tokens</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/tkrs.jl#L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.RepeatedTerm" href="#TextEncodeBase.RepeatedTerm"><code>TextEncodeBase.RepeatedTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RepeatedTerm(terms::TemplateTerm...; dynamic_type_id = false)</code></pre><p>A special term that indicate the <code>terms</code> sequence can appear zero or multiple times. Cannot be nested.  If <code>dynamic_type_id</code> is set, each repeat would add an offset value to the type id of those repeat <code>terms</code>.  The offset value if the number of repetiton, starting form <code>0</code>, times <code>dynamic_type_id</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/utils.jl#L571-L577">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.SequenceTemplate" href="#TextEncodeBase.SequenceTemplate"><code>TextEncodeBase.SequenceTemplate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SequenceTemplate(terms::TemplateTerm)(sequences...)</code></pre><p>Constructing a function by multiple <code>TemplateTerm</code> that indicate how to combine the input <code>sequences</code>. Return  a tuple of the result sequence and a type id (a special number associated with the template term) sequence.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; SequenceTemplate(ConstTerm(-1), InputTerm{Int}(), ConstTerm(-2))(1:5)[1] == TextEncodeBase.with_head_tail(1:5, -1, -2)
true

julia&gt; SequenceTemplate(ConstTerm(-1), InputTerm{Int}(), ConstTerm(-2))(1:5)
([-1, 1, 2, 3, 4, 5, -2], [1, 1, 1, 1, 1, 1, 1])

julia&gt; bert_template = SequenceTemplate(
           ConstTerm(&quot;[CLS]&quot;, 1), InputTerm{String}(1), ConstTerm(&quot;[SEP]&quot;, 1),
           RepeatedTerm(InputTerm{String}(2), ConstTerm(&quot;[SEP]&quot;, 2))
       )
SequenceTemplate{String}([CLS]:&lt;type=1&gt; Input:&lt;type=1&gt; [SEP]:&lt;type=1&gt; (Input:&lt;type=2&gt; [SEP]:&lt;type=2&gt;)...)

julia&gt; bert_template([&quot;hello&quot;, &quot;world&quot;])
([&quot;[CLS]&quot;, &quot;hello&quot;, &quot;world&quot;, &quot;[SEP]&quot;], [1, 1, 1, 1])

julia&gt; bert_template([&quot;hello&quot;, &quot;world&quot;], [&quot;today&quot;, &quot;is&quot;, &quot;a&quot;, &quot;good&quot;, &quot;day&quot;])
([&quot;[CLS]&quot;, &quot;hello&quot;, &quot;world&quot;, &quot;[SEP]&quot;, &quot;today&quot;, &quot;is&quot;, &quot;a&quot;, &quot;good&quot;, &quot;day&quot;, &quot;[SEP]&quot;], [1, 1, 1, 1, 2, 2, 2, 2, 2, 2])
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/utils.jl#L589-L617">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.Splittability" href="#TextEncodeBase.Splittability"><code>TextEncodeBase.Splittability</code></a> — <span class="docstring-category">Type</span></header><section><div><p>splittability trait</p><p>The splittability trait decide whether the given combination (tokenizer x tokenization x stage) is  splittable or not (<code>Splittable</code> or <code>UnSplittable</code>). For example, <code>DefaultTokenization</code> and <code>SentenceStage</code>  is splittable (i.e. <code>splittability(::DefaultTokenization, ::SentenceStage) = Splittable()</code>). The splittability  change the behavior of <code>tokenize</code>: if it&#39;s splittable, <code>tokenize</code> will try to call <code>splitting</code> on the input,  <code>wrap</code> each splitting result and recurse. Otherwise, it will directly call <code>wrap</code> and then recurse into <code>tokenize</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/base.jl#L107-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.TemplateTerm" href="#TextEncodeBase.TemplateTerm"><code>TextEncodeBase.TemplateTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type TemplateTerm{T} end</code></pre><p>Abstract type for term used in <a href="#TextEncodeBase.SequenceTemplate"><code>SequenceTemplate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/utils.jl#L529-L533">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.TextEncoder" href="#TextEncodeBase.TextEncoder"><code>TextEncodeBase.TextEncoder</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TextEncoder(tokenizer, vocab, process = nestedcall(getvalue))</code></pre><p>A simple encoder implementation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/encode.jl#L60-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.TextEncoder-Tuple{Any, TextEncoder}" href="#TextEncodeBase.TextEncoder-Tuple{Any, TextEncoder}"><code>TextEncodeBase.TextEncoder</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TextEncoder(builder, e::TextEncoder)</code></pre><p>Given an encoder, return a new encoder that has the same tokenizer and vocabulary. <code>builder</code> is  a function that take a encoder and return a new processing function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/encode.jl#L75-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.TokenStages" href="#TextEncodeBase.TokenStages"><code>TextEncodeBase.TokenStages</code></a> — <span class="docstring-category">Type</span></header><section><div><p>abstract type for type that wrap input into specific stage for control tokenization.</p><p>There are six builtin stages in TextEncodeBase (all abstract XStage &lt;: TokenStages):</p><pre><code class="nohighlight hljs">1. Document &lt;: DocumentStage: the input string is a full document,
 and thus need to be splitted into multiple sentence.
2. Sentence &lt;: SentenceStage: the input string is a full string,
 and thus need to be splitted into multiple part (SubSentence/Word/Token).
3. SubSentence &lt;: SubSentenceStage: special wrapper for case where the tokenizer
 does not directly break sentence all into words/tokens and these pieces contain
 multiple words/tokens, but you need the information that they are not full sentence.
4. Word &lt;: WordStage: the input string is a single word.
5. SubWord &lt;: SubWordStage: similar to SubSentence, but for word.
6. Token &lt;: TokenStage: the final piece of the tokenization process.
 Generally, it&#39;s used to specify the end of this piece and should
 never be splitted.</code></pre><p>Each wrapper have two field: <code>x</code> for the input, <code>meta</code> for extra information (<code>nothing</code> if not provided).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/base.jl#L27-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.Vocab" href="#TextEncodeBase.Vocab"><code>TextEncodeBase.Vocab</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Vocab(data::Vector{&lt;:AbstractString}, unk::AbstractString=&quot;[UNK]&quot;)</code></pre><p>Constructor for <code>Vocab</code>. <code>data</code> is the list of vocabulary word, can be nonunique.  The actual list will be the unique version of <code>data</code> (i.e. <code>vocab.list = unique(data)</code>).  <code>unk</code> is the indicator word for all unknown words. <code>unk</code> can be either in or not in <code>data</code>,  depends on the use case.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/vocab.jl#L13-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.Vocab-Union{Tuple{T}, Tuple{AbstractVector, Any}} where T" href="#TextEncodeBase.Vocab-Union{Tuple{T}, Tuple{AbstractVector, Any}} where T"><code>TextEncodeBase.Vocab</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Vocab{T}(data::AbstractVector, unk) where T</code></pre><p>construct Vocab with element type <code>T</code>. <code>unk</code> must be specified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/vocab.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.decode-Tuple{AbstractTextEncoder, Any}" href="#TextEncodeBase.decode-Tuple{AbstractTextEncoder, Any}"><code>TextEncodeBase.decode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decode(e::AbstractTextEncoder, x)</code></pre><p>Decode <code>x</code>. This is basically <a href="#TextEncodeBase.decode_indices-Tuple{AbstractTextEncoder, Any}"><code>decode_indices</code></a> but can be overload for post-processing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/encode.jl#L53-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.decode_indices-Tuple{AbstractTextEncoder, Any}" href="#TextEncodeBase.decode_indices-Tuple{AbstractTextEncoder, Any}"><code>TextEncodeBase.decode_indices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decode_indices(e::AbstractTextEncoder, x)</code></pre><p>Decode <code>x</code> by reverse lookup <code>x</code> in <code>e.vocab</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/encode.jl#L46-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.encode-Tuple{AbstractTextEncoder, Any}" href="#TextEncodeBase.encode-Tuple{AbstractTextEncoder, Any}"><code>TextEncodeBase.encode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">encode(e::AbstractTextEncoder, x)</code></pre><p>Encode <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/encode.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.encode_indices-Tuple{AbstractTextEncoder, Any}" href="#TextEncodeBase.encode_indices-Tuple{AbstractTextEncoder, Any}"><code>TextEncodeBase.encode_indices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">encode_indices(e::AbstractTextEncoder, x)</code></pre><p>Encode <code>x</code> without calling <code>lookup</code> bound with <code>e</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/encode.jl#L32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.lookup" href="#TextEncodeBase.lookup"><code>TextEncodeBase.lookup</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lookup(v::Vocab, x)</code></pre><p>Lookup <code>x</code> in <code>v</code>. <code>lookup</code> words depends on the type of <code>x</code>. If <code>x</code> is an integer,  return the <code>x</code>-th word on the vocabulary list (i.e. <code>v.list[x]</code>) and return the unknown word  if <code>x</code> is out-of-bound (<code>v.unk</code>). If <code>x</code> is a string, return the indice of <code>x</code> in the vocabulary  list (i.e <code>findfirst(==(x), v.list</code>) and return the unknown indice if <code>x</code> not found in the list.  If the unknown word <code>v.unk</code> is in the list, the unknown indice is its indice, otherwise 0.</p><p>This function is bidirectional except for <code>Vocab{&lt;:Integer}</code>. For integer vocabulary, this function  only get the <code>x</code>-th word (<code>v.list[x]</code>). Use <code>lookup(Int, v, x)</code> for explicit indice lookup.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; vocab = Vocab([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;])
Vocab{String, StaticArrays.SizedVector{3, String, Vector{String}}}(size = 3, unk = [UNK], unki = 0)

julia&gt; vocab_unk = Vocab([&quot;a&quot;, &quot;b&quot;, &quot;xxx&quot;], &quot;xxx&quot;)
Vocab{String, StaticArrays.SizedVector{3, String, Vector{String}}}(size = 3, unk = xxx, unki = 3)

julia&gt; lookup(vocab, &quot;b&quot;)
2

julia&gt; lookup(vocab, &quot;d&quot;)
0

julia&gt; lookup(vocab_unk, &quot;d&quot;)
3

julia&gt; lookup(vocab, 1)
&quot;a&quot;

julia&gt; lookup(vocab, 10000)
&quot;[UNK]&quot;

julia&gt; lookup(vocab_unk, 10000)
&quot;xxx&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/vocab.jl#L103-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.lookup-Tuple{AbstractTextEncoder, Any}" href="#TextEncodeBase.lookup-Tuple{AbstractTextEncoder, Any}"><code>TextEncodeBase.lookup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lookup(e::AbstractTextEncoder, x)</code></pre><p>Lookup <code>x</code> in encoder&#39;s vocabulary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/encode.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.lookup-Tuple{Any, Vocab, Any}" href="#TextEncodeBase.lookup-Tuple{Any, Vocab, Any}"><code>TextEncodeBase.lookup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lookup(Int, v::Vocab, x)</code></pre><p>The explicit version of <code>lookup(v, x)</code>. Lookup the indice of <code>x</code> in the vocabulary  list. <code>x</code> should have the same type as Vocab&#39;s element type.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; vocab_unk = Vocab([&quot;a&quot;, &quot;b&quot;, &quot;xxx&quot;], &quot;xxx&quot;)
Vocab{String, StaticArrays.SizedVector{3, String, Vector{String}}}(size = 3, unk = xxx, unki = 3)

julia&gt; lookup(Int, vocab_unk, &quot;b&quot;)
2
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/vocab.jl#L145-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.lookup-Tuple{Type{OneHot}, Vocab, Any}" href="#TextEncodeBase.lookup-Tuple{Type{OneHot}, Vocab, Any}"><code>TextEncodeBase.lookup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lookup(OneHot, v::Vocab, i)</code></pre><p>lookup <code>i</code> and convert into one-hot representation.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; lookup(OneHot, vocab, &quot;a&quot;)
3-element OneHot{3}:
 1
 0
 0

julia&gt; lookup(OneHot, vocab, [&quot;a&quot; &quot;b&quot;; &quot;c&quot; &quot;d&quot;])
3x2x2 OneHotArray{3, 3, Matrix{OneHot{0x00000003}}}:
[:, :, 1] =
 1  0
 0  0
 0  1

[:, :, 2] =
 0  0
 1  0
 0  0

julia&gt; lookup(OneHot, vocab, 3)
ERROR: DomainError with c:
cannot convert `lookup(::Vocab, 3)` = &quot;c&quot; into one-hot representation.
Stacktrace:
[...]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/vocab.jl#L212-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.lookup-Tuple{Vocab, AbstractArray}" href="#TextEncodeBase.lookup-Tuple{Vocab, AbstractArray}"><code>TextEncodeBase.lookup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lookup(v::Vocab, is::AbstractArray)</code></pre><p>recursively lookup value from <code>is</code></p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; lookup(vocab, [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;A&quot;, &quot;[UNK]&quot;])
5-element Vector{Int64}:
 2
 3
 1
 0
 0

julia&gt; lookup(vocab, [1, &quot;a&quot;, 0, &quot;A&quot;, &quot;[UNK]&quot;])
5-element Vector{Any}:
  &quot;a&quot;
 1
  &quot;[UNK]&quot;
 0
 0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/vocab.jl#L184-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.lookup-Tuple{Vocab, OneHotArray}" href="#TextEncodeBase.lookup-Tuple{Vocab, OneHotArray}"><code>TextEncodeBase.lookup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lookup(v::Vocab, i::OneHotArray)</code></pre><p>convert the one-hot representation back into words.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; lookup(OneHot, vocab, [&quot;a&quot; &quot;b&quot;; &quot;c&quot; &quot;d&quot;])
3x2x2 OneHotArray{3, 3, Matrix{OneHot{0x00000003}}}:
[:, :, 1] =
 1  0
 0  0
 0  1

[:, :, 2] =
 0  0
 1  0
 0  0

julia&gt; lookup(vocab, ans)
2×2 Matrix{String}:
 &quot;a&quot;  &quot;b&quot;
 &quot;c&quot;  &quot;[UNK]&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/vocab.jl#L248-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.lookup-Union{Tuple{T}, Tuple{Type{T}, Vocab{T, A} where A&lt;:AbstractVector{T}, Integer}} where T" href="#TextEncodeBase.lookup-Union{Tuple{T}, Tuple{Type{T}, Vocab{T, A} where A&lt;:AbstractVector{T}, Integer}} where T"><code>TextEncodeBase.lookup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lookup(::Type{T}, v::Vocab{T}, i::Integer) where T</code></pre><p>The explicit version of <code>lookup(v, i)</code>. Lookup the word at index <code>i</code> on vocabulary  list. <code>T</code> should be the same type as Vocab&#39;s element type. This method won&#39;t  work on integer vocab, use <code>lookup(v, i)</code> directly.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; vocab_unk = Vocab([&quot;a&quot;, &quot;b&quot;, &quot;xxx&quot;], &quot;xxx&quot;)
Vocab{String, StaticArrays.SizedVector{3, String, Vector{String}}}(size = 3, unk = xxx, unki = 3)

julia&gt; lookup(String, vocab_unk, 1)
&quot;a&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/vocab.jl#L164-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.nested2batch-Tuple{Any}" href="#TextEncodeBase.nested2batch-Tuple{Any}"><code>TextEncodeBase.nested2batch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nested2batch(x)</code></pre><p>convert nested array into single array</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; TextEncodeBase.nested2batch([[[1 2],[3 4]]])
1×2×2×1 Array{Int64, 4}:
[:, :, 1, 1] =
 1  2

[:, :, 2, 1] =
 3  4
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/utils.jl#L488-L505">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.preprocess-Tuple{AbstractTokenizer, TextEncodeBase.TokenStages}" href="#TextEncodeBase.preprocess-Tuple{AbstractTokenizer, TextEncodeBase.TokenStages}"><code>TextEncodeBase.preprocess</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">preprocess(tkr::AbstractTokenizer, x)</code></pre><p>Preprocess the input <code>x</code>. This is only called during <code>tkr(x)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/base.jl#L270-L274">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.process-Tuple{AbstractTextEncoder, Any}" href="#TextEncodeBase.process-Tuple{AbstractTextEncoder, Any}"><code>TextEncodeBase.process</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">process(e::AbstractTextEncoder, x)</code></pre><p>Use encoder&#39;s processing function to process <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/encode.jl#L18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.process-Tuple{AbstractTextEncoder}" href="#TextEncodeBase.process-Tuple{AbstractTextEncoder}"><code>TextEncodeBase.process</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">process(::AbstractTextEncoder)</code></pre><p>Get processing function of given encoder.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/encode.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.splittability" href="#TextEncodeBase.splittability"><code>TextEncodeBase.splittability</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">splittability(args...)</code></pre><p>Return the splittability (<code>Splittable</code>/<code>UnSplittable</code>) of given argument combination.  Overload to make a <code>TokenStages</code> splittable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/base.jl#L120-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.splittable-Tuple" href="#TextEncodeBase.splittable-Tuple"><code>TextEncodeBase.splittable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">splittable(args...)</code></pre><p>Return <code>true</code> if the splittability of given argument combination is <code>Splittable()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/base.jl#L128-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.splitting" href="#TextEncodeBase.splitting"><code>TextEncodeBase.splitting</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">splitting(t::AbstractTokenization, x::TokenStages)</code></pre><p>Split <code>x</code> given its tokenization stage. For example,  the default behavior of a document stage is splitting into  sentences (with <code>WordTokenizers.split_sentences</code>).</p><p>Overload this method for custom tokenization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/base.jl#L193-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.tokenization-Tuple{AbstractTokenizer}" href="#TextEncodeBase.tokenization-Tuple{AbstractTokenizer}"><code>TextEncodeBase.tokenization</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tokenization(::AbstractTokenizer) :: AbstractTokenization</code></pre><p>Return the tokenization object of given tokenizer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/base.jl#L263-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.tokenize-Tuple{AbstractTextEncoder, Any}" href="#TextEncodeBase.tokenize-Tuple{AbstractTextEncoder, Any}"><code>TextEncodeBase.tokenize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tokenize(e::AbstractTextEncoder, x)</code></pre><p>Use encoder&#39;s tokenizer to tokenize <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/encode.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.tokenize_procedure-Tuple{Any, Any, Any}" href="#TextEncodeBase.tokenize_procedure-Tuple{Any, Any, Any}"><code>TextEncodeBase.tokenize_procedure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tokenization_procedure(tokenizer, tokenizaton, stage)</code></pre><p>The procedure of tokenization (<code>splitting</code> + <code>wrap</code> + <code>tokenize</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/base.jl#L168-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.trunc_and_pad" href="#TextEncodeBase.trunc_and_pad"><code>TextEncodeBase.trunc_and_pad</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">trunc_and_pad(x, maxn, pad)</code></pre><p>Truncate <code>x</code> if length exceed <code>maxn</code>, and add <code>pad</code> at the end of x until all length are the same.  <code>x</code> can be either nested or single array. If <code>maxn</code> is <code>nothing</code>, the largest length of  the inner-most array will be used, then the behavior equals to <code>trunc_or_pad</code> with <code>nothing</code>.</p><pre><code class="nohighlight hljs">trunc_and_pad(x, maxn, pad, trunc_end = :tail, pad_end = :tail)</code></pre><p><code>trunc_end</code> and <code>pad_end</code> specified whether the truncation and padding happened at the begining of the  sentences or the end of the sentence. The value is either <code>:tail</code> (means the end) or <code>:head</code> (means the  begining).</p><pre><code class="nohighlight hljs">trunc_and_pad(maxn, pad, trunc_end = :tail, pad_end = :tail)</code></pre><p>Create a function that truncate input to be length &lt;= <code>maxn</code>, and add <code>pad</code> until all input has equal length.</p><p>see also: <a href="#TextEncodeBase.trunc_or_pad"><code>trunc_or_pad</code></a></p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; TextEncodeBase.trunc_and_pad(1:5, 7, -1)
5-element Vector{Int64}:
 1
 2
 3
 4
 5

julia&gt; TextEncodeBase.trunc_and_pad([1:5, 2:7], 10, -1)
2-element Vector{Vector{Int64}}:
 [1, 2, 3, 4, 5, -1]
 [2, 3, 4, 5, 6, 7]

julia&gt; TextEncodeBase.trunc_and_pad([1:5, [2:7, [1:2]]], nothing, -1)
2-element Vector{Vector}:
 [1, 2, 3, 4, 5, -1]
 Vector[[2, 3, 4, 5, 6, 7], [[1, 2, -1, -1, -1, -1]]]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/utils.jl#L392-L433">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.trunc_or_pad" href="#TextEncodeBase.trunc_or_pad"><code>TextEncodeBase.trunc_or_pad</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">trunc_or_pad(x, n, pad)</code></pre><p>Truncate <code>x</code> to length <code>n</code>, or add <code>pad</code> at the end of x until length equal <code>n</code>.  <code>x</code> can be either nested or single array. if <code>n</code> is <code>nothing</code>, the largest length of  the inner-most array will be used.</p><pre><code class="nohighlight hljs">trunc_or_pad(x, n, pad, trunc_end = :tail, pad_end = :tail)</code></pre><p><code>trunc_end</code> and <code>pad_end</code> specified whether the truncation and padding happened at the begining of the  sentences or the end of the sentence. The value is either <code>:tail</code> (means the end) or <code>:head</code> (means the  begining).</p><pre><code class="nohighlight hljs">trunc_or_pad(n, pad, trunc_end = :tail, pad_end = :tail)</code></pre><p>Create a function that will return new array with truncated or padded value of the input.</p><p>see also: <a href="#TextEncodeBase.trunc_and_pad"><code>trunc_and_pad</code></a></p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; TextEncodeBase.trunc_or_pad(1:5, 7, -1)
7-element Vector{Int64}:
  1
  2
  3
  4
  5
 -1
 -1

julia&gt; TextEncodeBase.trunc_or_pad([1:5, 2:7], 10, -1)
2-element Vector{Vector{Int64}}:
 [1, 2, 3, 4, 5, -1, -1, -1, -1, -1]
 [2, 3, 4, 5, 6, 7, -1, -1, -1, -1]

julia&gt; TextEncodeBase.trunc_or_pad([1:5, [2:7, [1:2]]], nothing, -1)
2-element Vector{Vector}:
 [1, 2, 3, 4, 5, -1]
 Vector[[2, 3, 4, 5, 6, 7], [[1, 2, -1, -1, -1, -1]]]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/utils.jl#L297-L340">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.with_head_tail-Tuple{AbstractArray, Any, Any}" href="#TextEncodeBase.with_head_tail-Tuple{AbstractArray, Any, Any}"><code>TextEncodeBase.with_head_tail</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">with_head_tail(x, head, tail)</code></pre><p>Return <code>[head; x; tail]</code>. Ignored if <code>head</code> or <code>tail</code> is <code>nothing</code>. <code>x</code> can be nested arrays.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; TextEncodeBase.with_head_tail(1:5, -1, -2)
7-element Vector{Int64}:
 -1
  1
  2
  3
  4
  5
 -2

julia&gt; TextEncodeBase.with_head_tail([1:5, 2:3], -1, -2)
2-element Vector{Vector{Int64}}:
 [-1, 1, 2, 3, 4, 5, -2]
 [-1, 2, 3, -2]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/utils.jl#L241-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.wrap" href="#TextEncodeBase.wrap"><code>TextEncodeBase.wrap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">wrap(t::AbstractTokenization, s::TokenStages, x)</code></pre><p>Mark the tokenization stage of <code>x</code>, which is part of the splitting result of <code>s</code>.  For example, if we are doing simple whitespace tokenization and at the sentence stage,  then <code>x</code> is just single word of <code>s</code> and thus return <code>Word(x)</code> (or <code>Token(x)</code>).  Skip if <code>x</code> is already a <code>TokenStages</code>. (this method only apply to splittable stages)</p><p>Overload this method to control the tokenization process.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/base.jl#L204-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.wrap-Tuple{AbstractTokenization, TextEncodeBase.TokenStages}" href="#TextEncodeBase.wrap-Tuple{AbstractTokenization, TextEncodeBase.TokenStages}"><code>TextEncodeBase.wrap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wrap(t::AbstractTokenization, x::TokenStages)</code></pre><p>A handler for unsplittable stages (token/word/...).</p><p>Overload this method for custom transform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/base.jl#L216-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.@stage" href="#TextEncodeBase.@stage"><code>TextEncodeBase.@stage</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@stage StageName
@stage StageName{A&lt;:SomeType, B}
@stage StageName AbstractStage
@stage StageName{A&lt;:SomeType, B} &lt;: AbstractStage</code></pre><p>Define <code>TokenStages</code> with two field (<code>x</code> and <code>meta</code>), it&#39;s single arguement constructor,  and add methods to <code>setmeta</code> and <code>setvalue</code>.</p><p>Equivalent to:</p><pre><code class="language-julia hljs">struct StageName{A&lt;:SomeType, B} &lt;: AbstractStage
    x::A
    meta::B
end

StageName(x) = StageName(x, nothing)
TextEncodeBase.setmeta(x::StageName, meta) = StageName(x.x, meta)
TextEncodeBase.setvalue(x::StageName, y) = StageName(y, x.meta)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/faedcaf691ed6b0be08cc532766d67df681e37df/src/macro.jl#L42-L64">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../design/">« Design</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Wednesday 9 November 2022 13:23">Wednesday 9 November 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
