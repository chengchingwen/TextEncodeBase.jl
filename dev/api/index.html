<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Api reference · TextEncodeBase.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://chengchingwen.github.io/TextEncodeBase.jl/api/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">TextEncodeBase.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><span class="tocitem">Home</span><ul><li><a class="tocitem" href="../">TextEncodeBase</a></li><li><a class="tocitem" href="../design/">Design</a></li><li class="is-active"><a class="tocitem" href>Api reference</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Home</a></li><li class="is-active"><a href>Api reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Api reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/master/docs/src/api.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Api-reference"><a class="docs-heading-anchor" href="#Api-reference">Api reference</a><a id="Api-reference-1"></a><a class="docs-heading-anchor-permalink" href="#Api-reference" title="Permalink"></a></h1><ul><li><a href="#TextEncodeBase.AbstractTokenization"><code>TextEncodeBase.AbstractTokenization</code></a></li><li><a href="#TextEncodeBase.AbstractTokenizer"><code>TextEncodeBase.AbstractTokenizer</code></a></li><li><a href="#TextEncodeBase.FlatTokenizer"><code>TextEncodeBase.FlatTokenizer</code></a></li><li><a href="#TextEncodeBase.NestedTokenizer"><code>TextEncodeBase.NestedTokenizer</code></a></li><li><a href="#TextEncodeBase.PipeGet"><code>TextEncodeBase.PipeGet</code></a></li><li><a href="#TextEncodeBase.Pipeline"><code>TextEncodeBase.Pipeline</code></a></li><li><a href="#TextEncodeBase.Pipelines"><code>TextEncodeBase.Pipelines</code></a></li><li><a href="#TextEncodeBase.Splittability"><code>TextEncodeBase.Splittability</code></a></li><li><a href="#TextEncodeBase.TokenStages"><code>TextEncodeBase.TokenStages</code></a></li><li><a href="#TextEncodeBase.Vocab-Union{Tuple{T}, Tuple{AbstractVector, Any}} where T"><code>TextEncodeBase.Vocab</code></a></li><li><a href="#TextEncodeBase.Vocab"><code>TextEncodeBase.Vocab</code></a></li><li><a href="#TextEncodeBase.lookup-Tuple{Type{OneHot}, Vocab, Any}"><code>TextEncodeBase.lookup</code></a></li><li><a href="#TextEncodeBase.lookup-Tuple{Vocab, AbstractArray}"><code>TextEncodeBase.lookup</code></a></li><li><a href="#TextEncodeBase.lookup-Tuple{Vocab, OneHotArray}"><code>TextEncodeBase.lookup</code></a></li><li><a href="#TextEncodeBase.lookup"><code>TextEncodeBase.lookup</code></a></li><li><a href="#TextEncodeBase.lookup-Tuple{Any, Vocab, Any}"><code>TextEncodeBase.lookup</code></a></li><li><a href="#TextEncodeBase.lookup-Union{Tuple{T}, Tuple{Type{T}, Vocab{T, A} where A&lt;:AbstractVector{T}, Integer}} where T"><code>TextEncodeBase.lookup</code></a></li><li><a href="#TextEncodeBase.nested2batch-Tuple{Any}"><code>TextEncodeBase.nested2batch</code></a></li><li><a href="#TextEncodeBase.preprocess-Tuple{AbstractTokenizer, TextEncodeBase.TokenStages}"><code>TextEncodeBase.preprocess</code></a></li><li><a href="#TextEncodeBase.splittability"><code>TextEncodeBase.splittability</code></a></li><li><a href="#TextEncodeBase.splittable-Tuple"><code>TextEncodeBase.splittable</code></a></li><li><a href="#TextEncodeBase.splitting"><code>TextEncodeBase.splitting</code></a></li><li><a href="#TextEncodeBase.tokenization-Tuple{AbstractTokenizer}"><code>TextEncodeBase.tokenization</code></a></li><li><a href="#TextEncodeBase.tokenize_procedure-Tuple{Any, Any, Any}"><code>TextEncodeBase.tokenize_procedure</code></a></li><li><a href="#TextEncodeBase.trunc_and_pad-Tuple{Any, Integer, Any}"><code>TextEncodeBase.trunc_and_pad</code></a></li><li><a href="#TextEncodeBase.with_head_tail-Tuple{Any, Any, Any}"><code>TextEncodeBase.with_head_tail</code></a></li><li><a href="#TextEncodeBase.wrap"><code>TextEncodeBase.wrap</code></a></li><li><a href="#TextEncodeBase.wrap-Tuple{AbstractTokenization, TextEncodeBase.TokenStages}"><code>TextEncodeBase.wrap</code></a></li><li><a href="#TextEncodeBase.@stage"><code>TextEncodeBase.@stage</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.AbstractTokenization" href="#TextEncodeBase.AbstractTokenization"><code>TextEncodeBase.AbstractTokenization</code></a> — <span class="docstring-category">Type</span></header><section><div><p>abstract type for tokenization.</p><p>The tokenization procedure is separate into multiple  <code>TokenStages</code> and recursive calls of <code>splitting</code>, <code>wrap</code>,  and <code>tokenize</code>. <code>splitting</code> break string into substrings,  <code>wrap</code> mark the substrings with new <code>TokenStages</code>, and  <code>tokenize</code> is responsible for the tokenization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/b259558bf7b459881a7d890fc52427beb34a8076/src/base.jl#L16-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.AbstractTokenizer" href="#TextEncodeBase.AbstractTokenizer"><code>TextEncodeBase.AbstractTokenizer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>abstract type for tokenizers.</p><p>Each tokenizer is link with a tokenization (by  defining <code>tokenization(::Tokenizer) = Tokenization()</code>).  The overall framework dispatch on both tokenizer and  tokenization, but most of the time we only add methods  for tokenization. This allow further composability and  can interfere the tokenization process with given  tokenizer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/b259558bf7b459881a7d890fc52427beb34a8076/src/base.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.FlatTokenizer" href="#TextEncodeBase.FlatTokenizer"><code>TextEncodeBase.FlatTokenizer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>tokenizer that return flat array instead of nested array of tokens</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/b259558bf7b459881a7d890fc52427beb34a8076/src/tkrs.jl#L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.NestedTokenizer" href="#TextEncodeBase.NestedTokenizer"><code>TextEncodeBase.NestedTokenizer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>tokenizer that return nested array instead of flat array of tokens</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/b259558bf7b459881a7d890fc52427beb34a8076/src/tkrs.jl#L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.PipeGet" href="#TextEncodeBase.PipeGet"><code>TextEncodeBase.PipeGet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PipeGet{name}()</code></pre><p>A special pipeline that get the wanted <code>name</code>s from namedtuple.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; p = Pipeline{:x}(identity, 1) |&gt; Pipeline{(:sinx, :cosx)}(sincos, 1) |&gt; PipeGet{(:x, :sinx)}()
Pipelines: Pipeline{x}((x,_)-&gt;identity(x)) =&gt; Pipeline{(:sinx, :cosx)}((x,_)-&gt;sincos(x)) =&gt; Pipeline{(:x, :sinx)}(__getindex__)

julia&gt; p(0.5)
(x = 0.5, sinx = 0.479425538604203)

julia&gt; p = Pipeline{:x}(identity, 1) |&gt; Pipeline{(:sinx, :cosx)}(sincos, 1) |&gt; PipeGet{:sinx}()
Pipelines: Pipeline{x}((x,_)-&gt;identity(x)) =&gt; Pipeline{(:sinx, :cosx)}((x,_)-&gt;sincos(x)) =&gt; Pipeline{(:x, :sinx)}(__getindex__)

julia&gt; p(0.5)
0.479425538604203
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/b259558bf7b459881a7d890fc52427beb34a8076/src/pipeline.jl#L39-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.Pipeline" href="#TextEncodeBase.Pipeline"><code>TextEncodeBase.Pipeline</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Pipeline{name}(f)</code></pre><p>Create a pipeline function with name. When calling the pipeline function, mark the result with <code>name</code>.  <code>f</code> should take two arguemnt: the input and a namedtuple (can be ignored) that the result will be  merged to. <code>name</code> can be either <code>Symbol</code> or tuple of <code>Symbol</code>s.</p><pre><code class="nohighlight hljs">Pipeline{name}(f, n) : equivalent to Pipeline{name}((args...)-&gt;f(args[n]))</code></pre><p>Create a pipline function with name. <code>f</code> should take one argument, it will be applied to either  the input or namedtuple depend on the value of <code>n</code>. <code>n</code> should be either <code>1</code> or <code>2</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; p = Pipeline{:x}(1) do x
           2x
       end
Pipeline{x}((x,_)-&gt;#27(x))

julia&gt; p(3)
(x = 6,)

julia&gt; p = Pipeline{:x}() do x, y
           y.a * x
       end
Pipeline{x}(#31)

julia&gt; p(2, (a=3, b=5))
(a = 3, b = 5, x = 6)

julia&gt; p = Pipeline{:x}(y-&gt;y.a^2, 2)
Pipeline{x}((_,y)-&gt;#29(y))

julia&gt; p(2, (a = 3, b = 5))
(a = 3, b = 5, x = 9)

julia&gt; p = Pipeline{(:sinx, :cosx)}(sincos, 1)
Pipeline{(:sinx, :cosx)}((x,_)-&gt;sincos(x))

julia&gt; p(0.5)
(sinx = 0.479425538604203, cosx = 0.8775825618903728)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/b259558bf7b459881a7d890fc52427beb34a8076/src/pipeline.jl#L73-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.Pipelines" href="#TextEncodeBase.Pipelines"><code>TextEncodeBase.Pipelines</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Pipelines(pipeline...)</code></pre><p>Chain of <code>Pipeline</code>s.</p><p><strong>Example</strong></p><pre><code class="language-julua hljs">julia&gt; pipes = Pipelines(Pipeline{:x}((x,y)-&gt;x), Pipeline{(:sinx, :cosx)}((x,y)-&gt;sincos(x)))
Pipelines: Pipeline{x}(#25) =&gt; Pipeline{(:sinx, :cosx)}(#26)

julia&gt; pipes(0.3)
(x = 0.3, sinx = 0.29552020666133955, cosx = 0.955336489125606)

# or use `|&gt;`
julia&gt; pipes = Pipeline{:x}((x,y)-&gt;x) |&gt; Pipeline{(:sinx, :cosx)}((x,y)-&gt;sincos(x))
Pipelines: Pipeline{x}(#25) =&gt; Pipeline{(:sinx, :cosx)}(#26)

julia&gt; pipes(0.3)
(x = 0.3, sinx = 0.29552020666133955, cosx = 0.955336489125606)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/b259558bf7b459881a7d890fc52427beb34a8076/src/pipeline.jl#L122-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.Splittability" href="#TextEncodeBase.Splittability"><code>TextEncodeBase.Splittability</code></a> — <span class="docstring-category">Type</span></header><section><div><p>splittability trait</p><p>The splittability trait decide whether the given combination (tokenizer x tokenization x stage) is  splittable or not (<code>Splittable</code> or <code>UnSplittable</code>). For example, <code>DefaultTokenization</code> and <code>SentenceStage</code>  is splittable (i.e. <code>splittability(::DefaultTokenization, ::SentenceStage) = Splittable()</code>). The splittability  change the behavior of <code>tokenize</code>: if it&#39;s splittable, <code>tokenize</code> will try to call <code>splitting</code> on the input,  <code>wrap</code> each splitting result and recurse. Otherwise, it will directly call <code>wrap</code> and then recurse into <code>tokenize</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/b259558bf7b459881a7d890fc52427beb34a8076/src/base.jl#L107-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.TokenStages" href="#TextEncodeBase.TokenStages"><code>TextEncodeBase.TokenStages</code></a> — <span class="docstring-category">Type</span></header><section><div><p>abstract type for type that wrap input into specific stage for control tokenization.</p><p>There are six builtin stages in TextEncodeBase (all abstract XStage &lt;: TokenStages):</p><pre><code class="nohighlight hljs">1. Document &lt;: DocumentStage: the input string is a full document,
 and thus need to be splitted into multiple sentence.
2. Sentence &lt;: SentenceStage: the input string is a full string,
 and thus need to be splitted into multiple part (SubSentence/Word/Token).
3. SubSentence &lt;: SubSentenceStage: special wrapper for case where the tokenizer
 does not directly break sentence all into words/tokens and these pieces contain
 multiple words/tokens, but you need the information that they are not full sentence.
4. Word &lt;: WordStage: the input string is a single word.
5. SubWord &lt;: SubWordStage: similar to SubSentence, but for word.
6. Token &lt;: TokenStage: the final piece of the tokenization process.
 Generally, it&#39;s used to specify the end of this piece and should
 never be splitted.</code></pre><p>Each wrapper have two field: <code>x</code> for the input, <code>meta</code> for extra information (<code>nothing</code> if not provided).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/b259558bf7b459881a7d890fc52427beb34a8076/src/base.jl#L27-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.Vocab" href="#TextEncodeBase.Vocab"><code>TextEncodeBase.Vocab</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Vocab(data::Vector{&lt;:AbstractString}, unk::AbstractString=&quot;[UNK]&quot;)</code></pre><p>Constructor for <code>Vocab</code>. <code>data</code> is the list of vocabulary word, can be nonunique.  The actual list will be the unique version of <code>data</code> (i.e. <code>vocab.list = unique(data)</code>).  <code>unk</code> is the indicator word for all unknown words. <code>unk</code> can be either in or not in <code>data</code>,  depends on the use case.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/b259558bf7b459881a7d890fc52427beb34a8076/src/vocab.jl#L13-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.Vocab-Union{Tuple{T}, Tuple{AbstractVector, Any}} where T" href="#TextEncodeBase.Vocab-Union{Tuple{T}, Tuple{AbstractVector, Any}} where T"><code>TextEncodeBase.Vocab</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Vocab{T}(data::AbstractVector, unk) where T</code></pre><p>construct Vocab with element type <code>T</code>. <code>unk</code> must be specified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/b259558bf7b459881a7d890fc52427beb34a8076/src/vocab.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.lookup" href="#TextEncodeBase.lookup"><code>TextEncodeBase.lookup</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lookup(v::Vocab, x)</code></pre><p>Lookup <code>x</code> in <code>v</code>. <code>lookup</code> words depends on the type of <code>x</code>. If <code>x</code> is an integer,  return the <code>x</code>-th word on the vocabulary list (i.e. <code>v.list[x]</code>) and return the unknown word  if <code>x</code> is out-of-bound (<code>v.unk</code>). If <code>x</code> is a string, return the indice of <code>x</code> in the vocabulary  list (i.e <code>findfirst(==(x), v.list</code>) and return the unknown indice if <code>x</code> not found in the list.  If the unknown word <code>v.unk</code> is in the list, the unknown indice is its indice, otherwise 0.</p><p>This function is bidirectional except for <code>Vocab{&lt;:Integer}</code>. For integer vocabulary, this function  only get the <code>x</code>-th word (<code>v.list[x]</code>). Use <code>lookup(Int, v, x)</code> for explicit indice lookup.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; vocab = Vocab([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;])
Vocab{String, StaticArrays.SizedVector{3, String, Vector{String}}}(size = 3, unk = [UNK], unki = 0)

julia&gt; vocab_unk = Vocab([&quot;a&quot;, &quot;b&quot;, &quot;xxx&quot;], &quot;xxx&quot;)
Vocab{String, StaticArrays.SizedVector{3, String, Vector{String}}}(size = 3, unk = xxx, unki = 3)

julia&gt; lookup(vocab, &quot;b&quot;)
2

julia&gt; lookup(vocab, &quot;d&quot;)
0

julia&gt; lookup(vocab_unk, &quot;d&quot;)
3

julia&gt; lookup(vocab, 1)
&quot;a&quot;

julia&gt; lookup(vocab, 10000)
&quot;[UNK]&quot;

julia&gt; lookup(vocab_unk, 10000)
&quot;xxx&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/b259558bf7b459881a7d890fc52427beb34a8076/src/vocab.jl#L97-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.lookup-Tuple{Any, Vocab, Any}" href="#TextEncodeBase.lookup-Tuple{Any, Vocab, Any}"><code>TextEncodeBase.lookup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lookup(Int, v::Vocab, x)</code></pre><p>The explicit version of <code>lookup(v, x)</code>. Lookup the indice of <code>x</code> in the vocabulary  list. <code>x</code> should have the same type as Vocab&#39;s element type.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; vocab_unk = Vocab([&quot;a&quot;, &quot;b&quot;, &quot;xxx&quot;], &quot;xxx&quot;)
Vocab{String, StaticArrays.SizedVector{3, String, Vector{String}}}(size = 3, unk = xxx, unki = 3)

julia&gt; lookup(Int, vocab_unk, &quot;b&quot;)
2
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/b259558bf7b459881a7d890fc52427beb34a8076/src/vocab.jl#L139-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.lookup-Tuple{Type{OneHot}, Vocab, Any}" href="#TextEncodeBase.lookup-Tuple{Type{OneHot}, Vocab, Any}"><code>TextEncodeBase.lookup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lookup(OneHot, v::Vocab, i)</code></pre><p>lookup <code>i</code> and convert into one-hot representation.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; lookup(OneHot, vocab, &quot;a&quot;)
3-element OneHot{3}:
 1
 0
 0

julia&gt; lookup(OneHot, vocab, [&quot;a&quot; &quot;b&quot;; &quot;c&quot; &quot;d&quot;])
3x2x2 OneHotArray{3, 3, Matrix{OneHot{0x00000003}}}:
[:, :, 1] =
 1  0
 0  0
 0  1

[:, :, 2] =
 0  0
 1  0
 0  0

julia&gt; lookup(OneHot, vocab, 3)
ERROR: DomainError with c:
cannot convert `lookup(::Vocab, 3)` = &quot;c&quot; into one-hot representation.
Stacktrace:
[...]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/b259558bf7b459881a7d890fc52427beb34a8076/src/vocab.jl#L206-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.lookup-Tuple{Vocab, AbstractArray}" href="#TextEncodeBase.lookup-Tuple{Vocab, AbstractArray}"><code>TextEncodeBase.lookup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lookup(v::Vocab, is::AbstractArray)</code></pre><p>recursively lookup value from <code>is</code></p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; lookup(vocab, [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;A&quot;, &quot;[UNK]&quot;])
5-element Vector{Int64}:
 2
 3
 1
 0
 0

julia&gt; lookup(vocab, [1, &quot;a&quot;, 0, &quot;A&quot;, &quot;[UNK]&quot;])
5-element Vector{Any}:
  &quot;a&quot;
 1
  &quot;[UNK]&quot;
 0
 0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/b259558bf7b459881a7d890fc52427beb34a8076/src/vocab.jl#L178-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.lookup-Tuple{Vocab, OneHotArray}" href="#TextEncodeBase.lookup-Tuple{Vocab, OneHotArray}"><code>TextEncodeBase.lookup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lookup(v::Vocab, i::OneHotArray)</code></pre><p>convert the one-hot representation back into words.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; lookup(OneHot, vocab, [&quot;a&quot; &quot;b&quot;; &quot;c&quot; &quot;d&quot;])
3x2x2 OneHotArray{3, 3, Matrix{OneHot{0x00000003}}}:
[:, :, 1] =
 1  0
 0  0
 0  1

[:, :, 2] =
 0  0
 1  0
 0  0

julia&gt; lookup(vocab, ans)
2×2 Matrix{String}:
 &quot;a&quot;  &quot;b&quot;
 &quot;c&quot;  &quot;[UNK]&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/b259558bf7b459881a7d890fc52427beb34a8076/src/vocab.jl#L242-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.lookup-Union{Tuple{T}, Tuple{Type{T}, Vocab{T, A} where A&lt;:AbstractVector{T}, Integer}} where T" href="#TextEncodeBase.lookup-Union{Tuple{T}, Tuple{Type{T}, Vocab{T, A} where A&lt;:AbstractVector{T}, Integer}} where T"><code>TextEncodeBase.lookup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lookup(::Type{T}, v::Vocab{T}, i::Integer) where T</code></pre><p>The explicit version of <code>lookup(v, i)</code>. Lookup the word at index <code>i</code> on vocabulary  list. <code>T</code> should be the same type as Vocab&#39;s element type. This method won&#39;t  work on integer vocab, use <code>lookup(v, i)</code> directly.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; vocab_unk = Vocab([&quot;a&quot;, &quot;b&quot;, &quot;xxx&quot;], &quot;xxx&quot;)
Vocab{String, StaticArrays.SizedVector{3, String, Vector{String}}}(size = 3, unk = xxx, unki = 3)

julia&gt; lookup(String, vocab_unk, 1)
&quot;a&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/b259558bf7b459881a7d890fc52427beb34a8076/src/vocab.jl#L158-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.nested2batch-Tuple{Any}" href="#TextEncodeBase.nested2batch-Tuple{Any}"><code>TextEncodeBase.nested2batch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nested2batch(x)</code></pre><p>convert nested array into single array</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; TextEncodeBase.nested2batch([[[1 2],[3 4]]])
1×2×2×1 Array{Int64, 4}:
[:, :, 1, 1] =
 1  2

[:, :, 2, 1] =
 3  4
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/b259558bf7b459881a7d890fc52427beb34a8076/src/utils.jl#L196-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.preprocess-Tuple{AbstractTokenizer, TextEncodeBase.TokenStages}" href="#TextEncodeBase.preprocess-Tuple{AbstractTokenizer, TextEncodeBase.TokenStages}"><code>TextEncodeBase.preprocess</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">preprocess(tkr::AbstractTokenizer, x)</code></pre><p>Preprocess the input <code>x</code>. This is only called during <code>tkr(x)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/b259558bf7b459881a7d890fc52427beb34a8076/src/base.jl#L270-L274">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.splittability" href="#TextEncodeBase.splittability"><code>TextEncodeBase.splittability</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">splittability(args...)</code></pre><p>Return the splittability (<code>Splittable</code>/<code>UnSplittable</code>) of given argument combination.  Overload to make a <code>TokenStages</code> splittable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/b259558bf7b459881a7d890fc52427beb34a8076/src/base.jl#L120-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.splittable-Tuple" href="#TextEncodeBase.splittable-Tuple"><code>TextEncodeBase.splittable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">splittable(args...)</code></pre><p>Return <code>true</code> if the splittability of given argument combination is <code>Splittable()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/b259558bf7b459881a7d890fc52427beb34a8076/src/base.jl#L128-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.splitting" href="#TextEncodeBase.splitting"><code>TextEncodeBase.splitting</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">splitting(t::AbstractTokenization, x::TokenStages)</code></pre><p>Split <code>x</code> given its tokenization stage. For example,  the default behavior of a document stage is splitting into  sentences (with <code>WordTokenizers.split_sentences</code>).</p><p>Overload this method for custom tokenization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/b259558bf7b459881a7d890fc52427beb34a8076/src/base.jl#L193-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.tokenization-Tuple{AbstractTokenizer}" href="#TextEncodeBase.tokenization-Tuple{AbstractTokenizer}"><code>TextEncodeBase.tokenization</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tokenization(::AbstractTokenizer) :: AbstractTokenization</code></pre><p>Return the tokenization object of given tokenizer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/b259558bf7b459881a7d890fc52427beb34a8076/src/base.jl#L263-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.tokenize_procedure-Tuple{Any, Any, Any}" href="#TextEncodeBase.tokenize_procedure-Tuple{Any, Any, Any}"><code>TextEncodeBase.tokenize_procedure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tokenization_procedure(tokenizer, tokenizaton, stage)</code></pre><p>The procedure of tokenization (<code>splitting</code> + <code>wrap</code> + <code>tokenize</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/b259558bf7b459881a7d890fc52427beb34a8076/src/base.jl#L168-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.trunc_and_pad-Tuple{Any, Integer, Any}" href="#TextEncodeBase.trunc_and_pad-Tuple{Any, Integer, Any}"><code>TextEncodeBase.trunc_and_pad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">trunc_and_pad(x, n, pad)</code></pre><p>truncate <code>x</code> to length <code>n</code>, otherwise add <code>pad</code> at the end of x until length equal <code>n</code>.  <code>x</code> can be either nested or single array (but the element type should not be subtype of abstract array).  if <code>n</code> is <code>nothing</code>, the largest length of the nested array will be used.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; TextEncodeBase.trunc_and_pad(1:5, 7, -1)
7-element Vector{Int64}:
  1
  2
  3
  4
  5
 -1
 -1

julia&gt; TextEncodeBase.trunc_and_pad([1:5, 2:7], 7, -1)
2-element Vector{Vector{Int64}}:
 [1, 2, 3, 4, 5, -1, -1]
 [2, 3, 4, 5, 6, 7, -1]

julia&gt; TextEncodeBase.trunc_and_pad([1:5, [2:7, [1:2]]], nothing, -1)
2-element Vector{Vector}:
 [1, 2, 3, 4, 5, -1]
 Vector[[2, 3, 4, 5, 6, 7], [[1, 2, -1, -1, -1, -1]]]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/b259558bf7b459881a7d890fc52427beb34a8076/src/utils.jl#L139-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.with_head_tail-Tuple{Any, Any, Any}" href="#TextEncodeBase.with_head_tail-Tuple{Any, Any, Any}"><code>TextEncodeBase.with_head_tail</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">with_head_tail(x, head, tail)</code></pre><p>Return <code>[head; x; tail]</code>. Ignored if <code>head</code> or <code>tail</code> is <code>nothing</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; TextEncodeBase.with_head_tail(1:5, -1, -2)
7-element Vector{Int64}:
 -1
  1
  2
  3
  4
  5
 -2

julia&gt; TextEncodeBase.with_head_tail([1:5, 2:3], -1, -2)
2-element Vector{Vector{Int64}}:
 [-1, 1, 2, 3, 4, 5, -2]
 [-1, 2, 3, -2]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/b259558bf7b459881a7d890fc52427beb34a8076/src/utils.jl#L99-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.wrap" href="#TextEncodeBase.wrap"><code>TextEncodeBase.wrap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">wrap(t::AbstractTokenization, s::TokenStages, x)</code></pre><p>Mark the tokenization stage of <code>x</code>, which is part of the splitting result of <code>s</code>.  For example, if we are doing simple whitespace tokenization and at the sentence stage,  then <code>x</code> is just single word of <code>s</code> and thus return <code>Word(x)</code> (or <code>Token(x)</code>).  Skip if <code>x</code> is already a <code>TokenStages</code>. (this method only apply to splittable stages)</p><p>Overload this method to control the tokenization process.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/b259558bf7b459881a7d890fc52427beb34a8076/src/base.jl#L204-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.wrap-Tuple{AbstractTokenization, TextEncodeBase.TokenStages}" href="#TextEncodeBase.wrap-Tuple{AbstractTokenization, TextEncodeBase.TokenStages}"><code>TextEncodeBase.wrap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wrap(t::AbstractTokenization, x::TokenStages)</code></pre><p>A handler for unsplittable stages (token/word/...).</p><p>Overload this method for custom transform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/b259558bf7b459881a7d890fc52427beb34a8076/src/base.jl#L216-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TextEncodeBase.@stage" href="#TextEncodeBase.@stage"><code>TextEncodeBase.@stage</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@stage StageName
@stage StageName{A&lt;:SomeType, B}
@stage StageName AbstractStage
@stage StageName{A&lt;:SomeType, B} &lt;: AbstractStage</code></pre><p>Define <code>TokenStages</code> with two field (<code>x</code> and <code>meta</code>), it&#39;s single arguement constructor,  and add methods to <code>setmeta</code> and <code>setvalue</code>.</p><p>Equivalent to:</p><pre><code class="language-julia hljs">struct StageName{A&lt;:SomeType, B} &lt;: AbstractStage
    x::A
    meta::B
end

StageName(x) = StageName(x, nothing)
TextEncodeBase.setmeta(x::StageName, meta) = StageName(x.x, meta)
TextEncodeBase.setvalue(x::StageName, y) = StageName(y, x.meta)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chengchingwen/TextEncodeBase.jl/blob/b259558bf7b459881a7d890fc52427beb34a8076/src/macro.jl#L42-L64">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../design/">« Design</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Saturday 19 February 2022 11:55">Saturday 19 February 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
